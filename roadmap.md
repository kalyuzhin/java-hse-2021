# Программа курса

#### Составитель: [Константин Леладзе](https://t.me/konstantinleladze)
#### Лектор: [Роман Гуров](https://t.me/bedragaren)


## Блок 1 «Основы процедурного программирования»
+ Что такое программирование. Какие задачи оно решает. Понятие инструкции и программы. Понятие процедурного программирования.
+ Концепция переменной: присвоение, изменение переменной, типы переменных. Правила присвоения переменных. Концепция оператора. Приоритет операторов (объяснить логику правилами математики).
+ Ветвление. Концепция **if / elif / else**.
+ Циклы: с предусловием, с постусловием. Понятие итератора цикла.
+ Массивы. Индексация массивов, цикл по массиву: прямой, обратный, двусторонний. Матрицы (двумерные массивы). Двумерные циклы. Многомерные массивы и циклы.
+ Функции, аргументы функций (обратить внимание на типы), возвращаемое значение функции и его тип, процедуры. Множественные точки выхода.

## Блок 2 «Основы процедурного программирования на Java»
+ Структура программы. Алфавит языка, функция `main`, ее аргументы.
+ Типы переменных в **Java**: примитивные и объектные.
+ Арифметика в **Java**. Операторы в **Java**.
+ Целочисленные и дробные типы. Приведение типов. Хранение данных в битах.
+ Тип `char`, `boolean`.
+ Условные управляющие конструкции в **Java**:
  + `if` / `else if` / `else` в **Java**
  + Циклы в **Java**: `while`, `do while`, `for`
+ Представление целочисленных переменных в памяти.
+ Побитовые операторы.
+ Представление дробных переменных в памяти на уровне понимания. Сравнение дробных чисел (пример с квадратным уравнением).
+ Условный оператор.
+ Литералы.
+ Область видимости переменных.
+ Ошибки компиляции: лексические, синтаксические, семантические.
+ Работа с классом `Math`.
+ Классы `BigInteger`, `BigDecimal`.
+ Массивы в **Java**. Многомерные массивы в **Java**. Демонстрация объектной природы массива.
+ Ключевое слово `final`.
+ Типы **String** и **StringBuilder**.
+ Задание методов в классе `Main`, рекурсия.
+ Стек и его переполнение.

## Блок 3 «Использование командной строки, знакомство с компилятором Java и документацией»
+ Что такое **JDK**. Процесс установки на **Mac OS** и **Ubuntu**. Как добавить команды **JDK** в переменную **PATH**.
+ Компилятор **Java**, вызов через `javac`. Байт-код, команда просмотра инструкций байт-кода `javap`.
+ Что такое **JVM** (пара слов о языках **Clojure**, **Scala**, **Jython**, **jRuby**, **Kotlin**, **Nashorn**, **Groovy**), команда `java`. Параметр `-classpath`.
+ Что такое **JRE**.
+ **Jar**-архивы, манифест. Команда `jar`. Пример упаковки файлов в архив командой `jar cfe`, просмотр и распаковка с командами `jar tf`, `jar xf`. Исполнение архивированной программы с **JVM**: `java -jar` (либо `java -classpath`).
+ Компиляция программы использующей сторонние библиотеки, использование `-classpath`.
+ **Javadocs**, пример.
+ Исполнение **byte**-кода интерпретатора (интерпретация). Сравнение с исполнением нативного кода. **JIT**. Адаптивная компиляция и оптимизации.
+ Знакомство с **IDE**: `IntelliJ IDEA`. Создание проекта и конфигурации. Сборка и исполнение программы в **IDE**. Дебаггер. Понятие стека вызовов.

## Блок 4 «Основы объектно ориентированного программирования»
+ Понятие класса, объекта (разница в этих терминах). Инкапсуляция. Примеры.
+ Поля класса, конструкторы (делегирующие), методы класса, `public` / `private` / `protected` модификаторы, аннотации.
+ **Immutable** классы, вложенные классы.
+ Перечисления.
+ Пакеты и модификаторы доступа: ключевое слово `package`, именование пакетов.
+ Пакеты стандартной библиотеки.
+ Модификаторы доступа, инкапсуляция на высоком уровне.

## Блок 5 «Наследование и абстракции»
+ Концепция наследования, его возможности и применения.
+ Реализация концепта наследования в **Java**: ключевое слово `extends`, конструктор наследника, ключевое слово `super`, переопределение методов, аннотация `@Override`.
+ Класс `Object`: методы `toString()`, `equals()`, `hashCode()`, пример переопределения этих методов в классе `ComplexNumber`.
+ Концепция полиморфизма. Реализация концепта динамического полиморфизма в **Java**. Абстрактные классы. Пример наследования: семейство геометрических фигур.
+ Интерфейс, мотивировка (решение проблемы отсутствия множественного наследования). `default`-методы. Пример: `CharSequence`, `Appendable` (реализация `StringBuilder`), `Comparator`.

## Блок 6 «Обработка ошибок и логирование»
+ Исключение. Мотивировка их наличия. Вывод необработанных исключений в `stdout`.
+ Демонстрация популярных исключений: `NullPointerException`, `ArrayIndexOutOfBoundsException`, `StringIndexOutOfBoundsException`, `FileNotFoundException`. Ошибки **JVM**, примеры: `OutOfMemoryError`, `NoClassDefFoundError`.
+ Класс `Throwable`. Ключевое слово `throw`. Методы `getMessage`, `printStackTrace`, `getStackTrace`, `getCause`, `getSuppressed`.
+ Группы исключений: `Error`, `Exception`, `RuntimeException`. Проверяемые исключения, ключевое слово `throws`.
+ Создание собственного типа исключений.
+ Обработка исключений, `try` / `catch`, несколько блоков `catch`, несколько типов исключений в одном блоке `catch`, блок `finally`, повторный `throw` из `try` / `catch`.
+ Проблема выброса исключения из `finally`, приводящая к потере исходного исключения. Решение этой проблемы с использованием **try with resources**. Интерфейс `AutoCloseable`, пример использования собственного ресурса.
+ Сильные и слабые гарантии исключений, примеры.
+ Логирование, пакет `java.util.logging`, класс `Logger`. Прикрепление класса логирования к классу. Методы `log`, `warning`, `setLevel`. Использование динамических данных для логирования, передача форматной строки в метод `log`, подстановка исключения третьим параметром, локализация сообщений.
+ Класс `java.util.logging.Handler`, его имплементации: `ConsoleHandler`, `FileHandler`, `SocketHandler`. Метод `addHandler`. Класс `java.util.logging.Formatter`, его имплементации: `SimpleFormatter`, `XMLFormatter`.
+ Управление логирования с использованием конфигурационного файла.

## Блок 7 «Дженерики»
+ Мотивация существования параметризованных типов (**Generic**’ов): например, метод для поиска минимального элемента в массиве, либо двоичное дерево поиска.
+ Ограничения **Generic**’ов:
  + Значение параметра не может быть примитивным типом, либо значением.
  + Внутри экземпляра **generic**-класса, его метода, либо **generic**-метода нельзя создавать экземпляр класса-параметра, массив с ним, а также использовать проверку `instanceof` с ним.
+ Пример **Generic**’а: `Optional`. Мотивация его существования:
  + чем `Optional` лучше **null**.
  + Упрощения проверок на **not null**: например `ifPresent`, `orElse`.
+ Параметризация класса **generic**’ом, создание поля-**generica**, метода, использующего **generic**. Невозможность использования **generic**’а в статическом методе. Параметризация метода **generic**’ом. Ключевое слово extends.
+ Пример реализации класса `Pair` (по-сути, аналог `Optional` для двух объектов). Статический фабричный метод `of`. Пример с `BiConsumer` и `ifPresent` для `Pair`. [Пример кода](https://pastebin.com/QHy9Pt7Y).
+ Инстанцирование **generic**-объектов. Пример с `Optional`. **Diamond operator**. Демонстрация использования **generic-**класса без **generic**-параметра.
+ Комбинирование **generic**’ов и наследования, невозможность `G<B> ga = new G<A>()` даже в случае, когда `B` – наследник `A`.
+ Интерфейсы `Consumer` и `Supplier`. Простейшая реализация методов `ifPresent` и `orElseGet` в `Optional`. Какие типы аргументов принимать, если хочется поддержать `Optional<B>.orElseGet(Supplier<C>)` и `Optional<B>.ifPresent(Consumer<A>)` в случае, когда `B` является наследником `A` и `C` – наследником `B`? (мотивация следующего пункта).
+ Маски: `? super T` и `? extends T`. Исправленные методы `ifPresent` и `orElseGet`. Полная имплементация `Optional`.
+ Синтаксическая конструкция `G<?>` (эквивалентна `G<? extends Object>`).

## Блок 8 «Коллекции»
+ Коллекции:
  + Мотивация (почему бы просто не использовать массивы?).
  + Ограничения (невозможность создания коллекций примитивных типов).
  + Примеры преимуществ: динамический размер, поддержка многопоточного кода.
+ Интерфейс `Collection`. Возможность конструирования коллекций друг из друга.
+ Интерфейс `Iterable` и итераторы. Доступ к итератору экземпляра коллекции. Методы `hasNext`, `next`, `remove`. Цикл **foreach**. метод `forEach`, пе6едача ссылки на метод.
+ Ограничения на тип-параметр коллекций: корректность реализации `equals` и `hashCode`.
+ Интерфейс `List`, его свойства и методы. Использование метода `subList` для удаления и модификации подотрезка.  Реализации интерфейса `List`: `ArrayList` и `LinkedList` (является одновременно и `List`’ом и `Deque`’ом), оценка времени операций, разница межды ними.
+ Интерфейс `Queue`, его свойства и методы, его наследник – интерфейс `Deque`, его реализации `ArrayDeque` и `LinkedList`.
+ Интерфейс `Set`, его свойства и методы. Его реализации: `HashSet` и `LinkedHashSet`. Требования к типу-параметру в случае `HashSet`: корректные `equals` и `hashCode`, неизменность объектов с точки зрения `hashCode` в ходе работы с коллекцией. Сравнение `HashSet` и `LinkedHashSet`. Наследник `Set`’а: `SortedSet`, его свойства и методы. Его реализация `TreeSet`. Понятие компаратора. Требования к типу-параметру: либо тип-параметр реализует интерфейс `Comparable`, либо в конструктор передается `Comparator`.
+ Интерфейс `Map` (формально, не является коллекцией, но схож с ней), его свойства и методы. Обход `Map`’ы: ключи, значения, пары ключ-значение.
+ Старые виды коллекций: `Vector`, `Stack`, `Dictionary`, `Hashtable`.
+ Утилитный класс `Collections`, его полезные методы: `shuffle`, `sort`, `unmodifiableSet`, `addAll`. Конвертация коллекции в `Array`: `toArray`, правильный вариант использования этого метода. Утилитный класс `Arrays`, его полезные методы: `equals`, `asList`.

## Блок 9 «Функциональные интерфейсы»
+ Функциональный интерфейс, аннотация `@FunctionalInterface`, интерфейс `runnable`. Инстанцирование функциональных интерфейсов в виде именнованного, либо анонимного класса, лямбда-выражения, либо ссылки на метод
+ Пример использования интерфейса `Runnable` для создания функции, замеряющей время работы другой функции.
+ Пакет `java.util.function`. Группы функциональных интерфейсов: `Consumer`’ы, `Supplier`’ы, `Predicate`’ы, `Function`’ы, `Operator`’ы.
+ Полезные методы встроенных функциональных интерфейсов: методы `negate` и `add` у `Predicate`’ов, методы `addThen` у `Consumer`’ов, методы `addThen` и `compose` у `Function` (и их различие), метод `comparing` у `Comparator`’ов.

## Блок 10 «Стримы»
+ **Stream API**. Интерфейс `Stream`. Отличия стрима от итератора. Отличия стрима от коллекции.
+ Примеры получения стрима из коллекции, **Reader**’а, директории, строки, массива, списка элементов. Генерирование **Stream**’а из **Supplier**’а. Получение **Stream**’а из **range**’а. Получение **Stream**’а итерированием по функции. Конкатенация **Stream**’ов, получение пустого **Stream**’а. Закрытие **Stream**’а (и необходимость этой операции).
+ Пример методов `IntStream`.
+ Операции:
  + Преобразования: `filter`, `limit`, `map`, `mapToObj`, `flatMapToInt`, `distinct`, `sorted`, `skip`, `peek` (передача `System::out::println`).
  + Терминальные операции: `forEach`, `findFirst`, `findAny`, `allMatch`, `anyMatch`, `noneMatch`, `min`, `max`, `count`, `sum`, `collect` (рассказать о `Collector`’е), reduce.
  + Остальные: `iterate`, `toArray`.
+ Подробный обзор `Collector`’ов и рассказ об интерфейсе этой сущности, мотивации ее существования и ключевых методах. Простые примеры `Collector`’ов: `toList`, `joining`, `summingInt`.
+ Пример написания функционального кода: вычисление факториала, определение палиндромности строки.

## Блок 11 «Рефлексия и аннотации»
+ Класс `Class`.
+ Три способа получения инстанса класса `Class`: вызовом метода `getClass` на объекте, из поля `class` у типа и с использованием статического метода `Class::forName`. `ClassNotFoundException`.
+ Методы `Class::getName`, `Class::getSimpleName`, `Class::getCanonicalName`, `Class::getTypeName`, `Class::getPackageName`, их отличия.
+ Метод `Class::getModifiers`, его возвращаемое значение, класс `Modifier` и его основные статические методы.
+ Методы `Class::getSuperclass` и `Class::getInterfaces`. Возвращаемое значение `Class::getInterfaces` для класса-интерфейса.
+ Задача: написать метод, получающий все интерфейсы, которые имплементирует ребенок в иерархии наследования. Конфигурация такая: `class C implements A, class D extends C implements B`. `Class<D>::getInterfaces` вернет `[B]` при вызове, а наш метод должен вернуть `[A, B]`.
+ Методы `Class::getFields`, `Class::getDeclaredFields`, `Class::getField`. `NoSuchFieldException`. Класс `Field` и его основные методы. Задача: Вывести все поля класса и их типы.
+ Методы `Class::getMethods`, `Class::getDeclaredMethods`, `Class::getMethod`. `NoSuchMethodException`. Класс `Method`, его основные методы и метод `invoke`. Задача: вызвать метод и обработать все возможные ошибки
+ Методы `Class::getConstructors`, `Class::getDeclaredConstructors`, `Class::getConstructor`. `NoSuchMethodException`. Класс `Constructor`, его основные методы и метод `newInstance`. Задача: вызвать конструктор и обработать все возможные ошибки
+ Задача: Вывести все методы и их сигнатуры (в том числе конструкторы)
+ Аннотации: мотивация, примеры аннотаций: `Deprecated`, `Override`, `SuppressWarnings`
+ Создание собственной аннотации, аннотации `Target`, `Retention`, `Inherited`, `Documented`. Все возможные значения `target` и `retention`. Примеры
+ Использование рефлексии для создания обработчика аннотаций. Методы `Class::isAnnotationPresent`, `Class::getAnnotations`, `Class::getAnnotation`, `Class::isAnnotation`. [Пример кода](https://pastebin.com/EDfK1JtF).

## Блок 12 «Работа с файловой системой»
+ Класс `java.io.File`. Конструктор класса из строки и из двух строк. `File.separator`, `File.pathSeparator`. Создание экземпляра класса `File` из абсолютного пути и из относительного: методы `isAbsolute`, `getAbsoluteFile` и `getAbsolutePath`. Методы `getPath`, `getName`, `getParent`, `getParentFile`. Символические ссылки. Канонический путь и методы `getCanonicalPath` и` getCanonicalFile`, объяснить почему он может бросить `java.io.IOException` (из-за символических ссылок). Методы `exists`, `isFile`, `isDirectory`, методы `length`, `lastModified`, `list`, `listFiles` (в том числе с передачей фильтра `FileFilter` и `FilenameFilter` в виде лямбда-выражения), `createNewFile`, `mkdir`, `mkdirs`, `delete`, `renameTo`.
+ Пакет `java.nio.file`, интерфейс `Path`. Класс `Paths`, его статический метод `get`. Методы конвертации: `Path.toFile` и `File.toPath`. Новые методы класса `Path`: `getNameCount`, `getName`, `resolveSibling`, `startsWith`, `relativize`. Методы `Files.copy`, `Files.move`, `Files.createDirectory`, `Files.createDirectories`.
+ Обработка директорий в потоковом режиме с использованием `DirectoryStream` внутри блока **try с ресурсами**, использование фильтра.
+ Метод `Files.walkFileTree`, интерфейс `FileVisitor` и его реализация `SimpleFileVisitor`.
+ Класс `FileSystems`, интерфейс `FileSystem`, метод `getRootDirectories`. Пример с обходом **zip**-архива.

## Блок 13 «Потоки данных»
+ Потоки байт: `InputStream`, `OutputStream`. Методы `read`, `skip`, `close` `InputStream`’а. Методы `write`, `flush`, `close` `OutputStream`’а. Копирование из `InputStream` в `OutputStream`.
+ Реализации `InputStream` и `OutputStream`. Интерфейсы `FileInputStream`, `FileOutputStream`, их создание с `Files.newInputStream` и `Files.newOutputStream`. Пример: чтение байткода класса `Main` с `getResourceAsStream`. Классы `ByteArrayInputStream`, `ByteArrayOutputStream`.
+ Запись в поток структурированных типизированных данных. Классы `DataInputStream` и `DataOutputStream`, оборачивание ими более низкоуровневого потока, примеры методов: `writeInt`, `readInt`. Классы `DeflaterOutputStream` и `InflaterOutputStream`. Обратить внимание на то, что закрытие внешнего потока приводит к закрытию вложенных.
+ Потоки символов. Абстрактные классы `Reader` и `Writer`, их методы. Классы `InputStreamReader` и `InputStreamWriter`, кодировка, класс `StandardCharsets`, класс `Charset`, методы `forName`, `defaultCharset`. Классы `FileReader` и `FileWriter`. Классы `CharArrayReader`, `StringReader`, `CharArrayWriter` и `StringWriter`. Класс `BufferedReader`, метод `readLine`. Пример: чтение файла построчно с `BufferedReader` в **UTF8** кодировке (показать старый способ и новый способ с классом `newBufferedReader`). Классы `newBufferedReader` и `newBufferedWriter`. Классы `PrintWriter` и `PrintStream` (+ их отличие). Класс `Scanner`, его параметры (разделитель, локаль).
+ Сериализация и десериализация данных, маркерный интерфейс `Serializable`. Поле `serialVersionUID`, модификатор `transient`.
+ Классы `ObjectOutputStream` и `ObjectInputStream`, методы `readObject`, `writeObject`.

## Блок 14 «Основы сетевого программирования»
+ Базовые понятия: сеть, протокол `ethernet`, протокол `ip`, `ip`-адрес, `port`.
+ Протоколы **UDP** и **TCP**: отличия, преимущества и недостатки одного перед другим, области их применения.
+ **HTTP** протокол: заголовки и тело запроса и ответа, статус ответа. Примеры различных типов запроса. Протокол **HTTP 1.1** и отличия от **HTTP 1.0**. Аутентификация.
+ Понятие `Socket`’а. Обмен данными по сети, класс `Socket`, его методы `getInputStream` и `getOutputStream`, отправка запроса **GET**
+ Написание простейшего **HTTP**-клиента, написание простейшего **HTTP**-сервера на сокетах (без использования встроенных `HTTP` клиента и сервера).
+ **Postman**: что такое и как пользоваться, демонстрация работы с приложением.
